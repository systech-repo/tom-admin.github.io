<!DOCTYPE html>
<html lang="fr">
<head>
		<title>tom-admin &mdash; GNU/Linux Networking - Technique</title>
		<meta charset="utf-8" />
		<link rel="profile" href="http://gmpg.org/xfn/11" />
		<link rel="stylesheet" type="text/css" href="https://tom-admin.github.io/theme/css/style.css" />
		<link rel='stylesheet' id='oswald-css'  href='http://fonts.googleapis.com/css?family=Oswald&#038;ver=3.3.2' type='text/css' media='all' />
		<style type="text/css">
			body.custom-background { background-color: #f5f5f5; }
		</style>
		<link rel="alternate" type="application/atom+xml"
			title="tom-admin — Flux Atom"
			href="https://tom-admin.github.io/" /> 
		<!--[if lte IE 8]><script src="https://tom-admin.github.io/theme/js/html5shiv.js"></script><![endif]-->
</head>

<body class="home blog custom-background " >
	<div id="container">
		<div id="header">
				<h1 id="site-title"><a href="https://tom-admin.github.io">tom-admin</a></h1>
<h2 id="site-description">#!/dev/tom-admin</h2>		</div><!-- /#banner -->
		
		<div id="menu">
			<div class="menu-navigation-container">
				<ul id="menu-navigation" class="menu">
						<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://tom-admin.github.io/category/astuces.html">Astuces</a></li>
						<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://tom-admin.github.io/category/linux.html">Linux</a></li>
						<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://tom-admin.github.io/category/memento.html">Memento</a></li>
						<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://tom-admin.github.io/category/pelican.html">Pelican</a></li>
						<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://tom-admin.github.io/category/python.html">Python</a></li>
						<li class="active" class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://tom-admin.github.io/category/revisions.html">Révisions</a></li>
						<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://tom-admin.github.io/category/scripting.html">Scripting</a></li>

				</ul>
			</div> <!--/#menu-navigation-container-->
		</div><!-- /#menu -->
		
		<div class="page-title">
		</div>
	
		<div id="contents">

<div class="post type-post status-publish format-standard hentry category-general" id="post">
	<div class="entry-meta">
		<div class="date"><a href="https://tom-admin.github.io/gnulinux-networking-technique.html">ven. 11 septembre 2015</a></div>
		<span class="byline">By <a href="https://tom-admin.github.io/author/mobius.html">Mobius</a></span>
			<span class="cat-links"><a href="https://tom-admin.github.io/category/revisions.html" title="View all posts in Révisions" rel="category tag">Révisions</a></span>
	</div> <!-- /#entry-meta -->
	<div class="main">
		<h2 class="entry-title">
			<a href="https://tom-admin.github.io/gnulinux-networking-technique.html" title="Permalink to GNU/Linux Networking - Technique" rel="bookmark">GNU/Linux Networking - Technique</a>
		</h2>
		<div class="entry-content">
			<div class="section" id="configuration-du-materiel">
<h2>Configuration du matériel</h2>
<p>Aujourd'hui, la prise en charge du matériel réseau pour la plupart des distributions GNU/Linux n'est plus un problème, particulièrement la gestion des interfaces réseau filaires qui seront généralement fonctionnelles post-installation. La prise en charge de la technologie <strong>wireless fidelity</strong> est quant elle plus tendancieuse, en effet de nombreuses cartes ne sont pas directement reconnues après l'installation de votre distribution et cela en raison de la non implémentation des drivers appropriés. Il faut savoir que des paquets sont néanmoins disponibles pour remédier à ces problèmes récurrents :</p>
<ul class="simple">
<li><strong>firmware-realtek</strong> permettant la prise en charge des équipements Realteck</li>
<li><strong>firmware-ralink</strong> permettant la prise en charge des équipements Ralink</li>
<li><strong>firmware-iwlwifi</strong> permettant la prise en charge des équipements Intel</li>
<li><strong>firmware-atheros</strong> permettant la prise en charge des équipements Atheros.</li>
</ul>
<p>Mais malgré ces pilotes disponibles sous GNU/Linux, parfois les cartes peuvent se montrer récalcitrantes et ne voudront toujours pas fonctionner. Sachez à titre d'information qu'un outil <strong>ndiswrapper</strong> permettra d'utiliser les pilotes Windows pour les implémenter dans votre distribution GNU/Linux.</p>
<div class="section" id="les-commandes-pour-interferer-sur-le-materiel-reseau">
<h3>Les commandes pour interférer sur le matériel réseau</h3>
<p>La première commande à connaître sous GNU/Linux pour vérifier que votre matériel réseau est bel et bien fonctionnel est la commande <strong>ifconfig</strong>, diminutif de l'anglais <em>interface configuration</em>. Il faut savoir que cette commande aujourd'hui est dépréciée au profit de la commande <strong>ip</strong> mais reste encore très largement répandue et utilisée. Cette commande va permettre de contrôler l'état de votre interface réseau, autrement dit savoir si votre carte ethernet, wifi sont actives, démarrées, si elles bénéficient d'un adressage IP opérationnel ... Voici les principales combinaisons</p>
<pre class="code bash literal-block">
<span class="c1"># voir l'ensemble des cartes actives et fonctionnelles
</span>$ ifconfig

<span class="c1"># voir toutes les cartes présentes (actives et non actives)
</span>$ ifconfig --all

<span class="c1"># Désactiver l'interface ethernet n°1
</span>$ ifconfig eth1 down

<span class="c1"># activer l'interface ethernet n°1
</span>$ ifconfig eth1 up

<span class="c1"># attribuer dynamiquement un adressage IP à l'interface ethernet n°1
</span>$ ifconfig eth1 192.168.1.1 netmask 255.255.255.0

<span class="c1"># ajouter une adresse virtuelle à l'interface ethernet n°1
</span>$ ifconfig eth1:0 10.1.1.1 netmask 255.255.0.0
</pre>
<p>Pour ceux qui viennent à se demander à quoi sert d'ajouter une adresse virtuelle à une interface, je les invite à lire mon prochain cours traitant justement de l'<strong>IP aliasing</strong>. Pour expliquer très rapidement, cela consiste à attribuer une deuxième adresse IP à notre interface, autrement si vous amusez à faire un ping sur votre adressage principal (192.168.1.1 ici) et un autre sur votre alias virtuel (10.1.1.1) voici les résultats :</p>
<pre class="code bash literal-block">
$ ping 192.168.1.1
PING 192.168.1.1 <span class="o">(</span>192.168.1.1<span class="o">)</span> 56<span class="o">(</span>84<span class="o">)</span> bytes of data.
<span class="m">64</span> bytes from 192.168.1.1: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">3</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.073 ms
<span class="m">64</span> bytes from 192.168.1.1: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">4</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.078 ms
--- 192.168.1.1 ping statistics ---
<span class="m">4</span> packets transmitted, <span class="m">4</span> received, 0% packet loss, <span class="nb">time</span> 2999ms
rtt min/avg/max/mdev <span class="o">=</span> 0.073/0.075/0.078/0.009 msu

$ ping 10.1.1.1
PING 10.1.1.1 <span class="o">(</span>10.1.1.1<span class="o">)</span> 56<span class="o">(</span>84<span class="o">)</span> bytes of data.
<span class="m">64</span> bytes from 10.1.1.1: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">3</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.073 ms
<span class="m">64</span> bytes from 10.1.1.1: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">4</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.078 ms
--- 10.1.1.1  ping statistics ---
<span class="m">4</span> packets transmitted, <span class="m">4</span> received, 0% packet loss, <span class="nb">time</span> 2999ms
rtt min/avg/max/mdev <span class="o">=</span> 0.073/0.075/0.078/0.009 msu
</pre>
<p>Les deux résultats s'avèrent être concluant, votre interface répond désormais à deux adresses IP différentes. Intéressons nous dès à présent à la notion de routes, étape fondamentale dans le monde des réseaux. Ce nom route est à assimiler aux routes ferroviaires, routières que nous connaissons très bien. Il s'agit de créer un itinéraire pour permettre l'acheminer de vos paquets TCP/IP, à travers le réseau pour garantir l'échange entre par exemple une machine cliente et un serveur web. Les commandes les plus efficientes pour la gestion des routes sont les suivantes :</p>
<pre class="code bash literal-block">
<span class="c1"># ajouter une route pour le réseau 172.15.0.0/16 ayant comme passerelle par défaut 192.168.1.254
</span>$ route add -net 172.15.0.0 netmask 255.255.0.0 gw 192.168.1.254

<span class="c1"># supprimer une route emmenant au réseau 172.15.0.0/16
</span>$ route del -net 172.15.0.0 netmask 255.255.0.0

<span class="c1"># supprimer la route par défaut
</span>$ route del default

<span class="c1"># ajouter la route par défaut
</span>$ route add default gw 192.168.1.254
</pre>
</div>
</div>

		</div> <!--/#entry-content-->
	</div> <!--/#main-->
</div>  <!--/#post-->

		</div>
		
		<div id="footer">
			<p>Powered by <a href="http://getpelican.com">Pelican</a>, theme by <a href="http://bunnyman.info">tBunnyMan</a>.</p>
		</div><!-- /#footer -->
	</div><!-- /#container -->
	<div style="display:none"></div>
</body>
</html>