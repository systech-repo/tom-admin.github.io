<!DOCTYPE html>
<html lang="fr">
<head>
		<title>tom-admin &mdash; I love Bash #1</title>
		<meta charset="utf-8" />
		<link rel="profile" href="http://gmpg.org/xfn/11" />
		<link rel="stylesheet" type="text/css" href="https://tom-admin.github.io/theme/css/style.css" />
		<link rel='stylesheet' id='oswald-css'  href='http://fonts.googleapis.com/css?family=Oswald&#038;ver=3.3.2' type='text/css' media='all' />
		<style type="text/css">
			body.custom-background { background-color: #f5f5f5; }
		</style>
		<link rel="alternate" type="application/atom+xml"
			title="tom-admin — Flux Atom"
			href="https://tom-admin.github.io/" /> 
		<!--[if lte IE 8]><script src="https://tom-admin.github.io/theme/js/html5shiv.js"></script><![endif]-->
</head>

<body class="home blog custom-background " >
	<div id="container">
		<div id="header">
				<h1 id="site-title"><a href="https://tom-admin.github.io">tom-admin</a></h1>
<h2 id="site-description">#!/dev/tom-admin</h2>		</div><!-- /#banner -->
		
		<div id="menu">
			<div class="menu-navigation-container">
				<ul id="menu-navigation" class="menu">
						<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://tom-admin.github.io/category/astuces.html">Astuces</a></li>
						<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://tom-admin.github.io/category/linux.html">Linux</a></li>
						<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://tom-admin.github.io/category/memento.html">Memento</a></li>
						<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://tom-admin.github.io/category/pelican.html">Pelican</a></li>
						<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://tom-admin.github.io/category/python.html">Python</a></li>
						<li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://tom-admin.github.io/category/revisions.html">Révisions</a></li>
						<li class="active" class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://tom-admin.github.io/category/scripting.html">Scripting</a></li>

				</ul>
			</div> <!--/#menu-navigation-container-->
		</div><!-- /#menu -->
		
		<div class="page-title">
		</div>
	
		<div id="contents">

<div class="post type-post status-publish format-standard hentry category-general" id="post">
	<div class="entry-meta">
		<div class="date"><a href="https://tom-admin.github.io/i-love-bash-1.html">mar. 24 février 2015</a></div>
		<span class="byline">By <a href="https://tom-admin.github.io/author/mobius.html">Mobius</a></span>
			<span class="cat-links"><a href="https://tom-admin.github.io/category/scripting.html" title="View all posts in Scripting" rel="category tag">Scripting</a></span>
	</div> <!-- /#entry-meta -->
	<div class="main">
		<h2 class="entry-title">
			<a href="https://tom-admin.github.io/i-love-bash-1.html" title="Permalink to I love Bash #1" rel="bookmark">I love Bash #1</a>
		</h2>
		<div class="entry-content">
			<div class="section" id="la-fameuse-stdin">
<h2>La fameuse STDIN</h2>
<div class="section" id="preambule">
<h3>Préambule</h3>
<p>Tout programme informatique est frillant des entrées et sorties en vue d'interagir avec l'utilisateur soit par l'intermédiaire des périphériques <em>d'entrée</em> comme par exemple le <em>clavier</em> ou encore d'afficher le résultat attendu sur un périphérique de <em>sortie</em> comme <em>l'écran</em>. Un problème subsiste, la diversité des sorties potentielles. En effet, la sortie sur un périphérique comme <em>l'écran</em> aura des mécanismes différents que l'enregistrement de données dans un <em>fichier</em>. Voilà
pourquoi, nos systèmes dérivés d'Unix, pallient cette difficulté de traitement en considérant que tout est <em>fichier</em> (votre connexion, ...). Cette abstraction est dès lors indispensable en vue de faciliter la prise en charge du pluralisme des sorties.</p>
</div>
<div class="section" id="faire-pointer-la-sortie-dans-notre-terminal-ou-encore-une-fenetre">
<h3>Faire pointer la sortie dans notre terminal ou encore une fenêtre</h3>
<pre class="code bash literal-block">
$ <span class="nb">echo</span> Ceci est un exemple
</pre>
<p>Ce code précédent permet d'afficher dans votre console le texte <em>Ceci est un exemple</em> grâce à la commande <strong>echo</strong>. Cette commande n'affiche pas uniquement du texte mais tout type <em>d'arguments</em> passés (des variables...). Dans le code ci-dessus, vous remarquerez l'absence de guillemets autour de notre chaîne de caractère et ceci est tout à fait normal : le but est avant tout de comprendre le fonctionnement de la commande, ici la commande echo va bel et bien afficher le texte mais ne va en
réalité pas comprendre qu'il s'agit d'une seule et même chaîne de caractère mais comme trois arguments distincts. Ainsi, si vous faites le test de la commande suivante :</p>
<pre class="code bash literal-block">
$ <span class="nb">echo</span> Ceci             est         un exemple
</pre>
<p>Tout les espaces ne vont pas être interprétés car les guillemets sont absentes. Ici, bash va comprendre que vous lui soumettez trois arguments et donc séparer les résultats d'un seul espace. Maintenant faites le test suivant :</p>
<pre class="code bash literal-block">
$ <span class="nb">echo</span> <span class="s2">&quot;Ceci      est       un exemple&quot;</span>
</pre>
<p>Dans ce cas, bash va bien interpréter les espaces par l'intermédiaire des guillemets, signifiant qu'il s'agit d'un seul et même argument. Une autre précision, l'utilisation des guillemets et des apostrophes n'a pas les mêmes répercussions : si vous utilisez des guillemets <strong>&quot; &quot;</strong>, bash va <em>parser</em> autrement dit analyser véritablement le contenu en interprétant la présence d'éventuelle(s) variable(s) mais si vous optez pour des apostrophes alors les variables seront inopérantes.</p>
<pre class="code bash literal-block">
<span class="ch">#!/bin/bash -
</span><span class="c1"># variable
</span><span class="nv">prenom</span><span class="o">=</span><span class="s1">'Thomas'</span>
<span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$prenom</span><span class="s2">&quot;</span> <span class="c1"># va renvoyer à l'écran &quot;Thomas&quot;
</span><span class="nb">echo</span> <span class="s1">'$prenom'</span> <span class="c1"># va renvoyer à l'écran $prenom</span>
</pre>
<p>Dans la mesure du possible, il faut utiliser les guillemets lorsque cela est vraiment nécessaire sinon des apostrophes pour maximiser la vitesse d'exécution du programme, car oui l'analyse sous-jacente à l'utilisation des guillemets va ralentir votre script. Vous me croyez pas ? Faites donc alors ce test : enregistrez dans un premier fichier <em>guillemets.sh</em> le code suivant :</p>
<pre class="code bash literal-block">
<span class="ch">#!/bin/bash -
</span><span class="nv">i</span><span class="o">=</span>0
<span class="nb">time</span> <span class="k">while</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$i</span><span class="s2">&quot;</span> -ne <span class="m">50000</span> <span class="o">]</span><span class="p">;</span>
<span class="k">do</span>
    <span class="nb">echo</span> <span class="s2">&quot;Ceci est un test de rapidité&quot;</span> 1&gt;/dev/null <span class="c1"># on redirige la sortie standard vers le périphérique null
</span>    <span class="nb">let</span> <span class="nv">i</span><span class="o">=</span><span class="nv">$i</span>+1
<span class="k">done</span>
</pre>
<p>Maintenant faites la même chose en enregistrant le code suivant dans un autre fichier <em>apostrophes.sh</em>:</p>
<pre class="code bash literal-block">
<span class="ch">#!/bin/bash -
</span><span class="nv">i</span><span class="o">=</span>0
<span class="nb">time</span> <span class="k">while</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$i</span><span class="s2">&quot;</span> -ne <span class="m">50000</span> <span class="o">]</span><span class="p">;</span>
<span class="k">do</span>
    <span class="nb">echo</span> <span class="s1">'Ceci est un test de rapidité'</span> 1&gt;/dev/null <span class="c1"># permet de ne pas voir à l'écran les lignes
</span>    <span class="nb">let</span> <span class="nv">i</span><span class="o">=</span><span class="nv">$i</span>+1
<span class="k">done</span>
</pre>
<p>Faites les commandes suivantes :</p>
<pre class="code bash literal-block">
$ bash guillemets.sh
$ bash apostrophes.sh
</pre>
<p>Vous verrez directement la différence de temps d'exécution des deux scripts et l'avantage d'utiliser les guillemets uniquement si le besoin se fait sentir ! pour ma part la différence est la suivante :</p>
<pre class="code bash literal-block">
bash apostrophes.sh
real 0m1.691s
user 0m1.470s
sys  0m0.216s

bash guillemets.sh
real 0m1.808s
user 0m1.568s
sys  0m0.235s
</pre>
</div>
<div class="section" id="designons-notre-sortie">
<h3>Designons notre sortie</h3>
<p>Une autre commande très utile et dérivée du langage C est la grande, l'impertinente <em>printf</em>. Le fonctionnement est le suivant : le premier argument est une chaîne de format, les arguments suivants sont mis en forme en toute corrélation avec la chaîne de format matérialisée par <strong>%</strong>.</p>
<pre class="code bash literal-block">
$ <span class="nb">printf</span> <span class="s1">'%s = %d\n'</span> Code <span class="nv">$?</span>
</pre>
<p>Ce code nous permet de récupérer le code de la dernière commande et de mettre en forme à l'écran l'affichage grâce à la commande <em>printf</em>. L'instruction <em>%s</em> permet de préciser qu'il s'agit d'une chaîne de caractère (<em>s</em> pour <em>string</em>) et <em>%d</em> permet de préciser qu'il s'agit d'un nombre (<em>d</em> pour <em>decimal</em>). Enfin le caractère <em>n</em> permet de sauter une ligne dans une interface commande (<em>n</em> pour <em>newline</em>).</p>
</div>
<div class="section" id="ecrire-une-chaine-de-caractere-sans-sauter-de-ligne">
<h3>Ecrire une chaîne de caractère sans sauter de ligne :</h3>
<p>Les deux instructions <em>echo</em> comme <em>printf</em> permettent de répondre à cette problématique :</p>
<pre class="code bash literal-block">
$ <span class="nb">echo</span> -n <span class="s1">'Super exemple'</span> <span class="c1"># -n permet de ne pas sauter de ligne
</span>$ <span class="nb">echo</span> -e <span class="s1">'Super exemple\c'</span> <span class="c1"># -e permet d'interpréter les séquences d'échappement
</span>$ <span class="nb">printf</span> <span class="s2">&quot;%s&quot;</span> Super exemple
</pre>
</div>
</div>

		</div> <!--/#entry-content-->
	</div> <!--/#main-->
</div>  <!--/#post-->

		</div>
		
		<div id="footer">
			<p>Powered by <a href="http://getpelican.com">Pelican</a>, theme by <a href="http://bunnyman.info">tBunnyMan</a>.</p>
		</div><!-- /#footer -->
	</div><!-- /#container -->
	<div style="display:none"></div>
</body>
</html>